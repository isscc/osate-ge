package org.osate.ge.internal.diagram.runtime.layout.connections;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Objects;

import org.osate.ge.graphics.Point;
import org.osate.ge.internal.diagram.runtime.Dimension;

// TODO: Rename
public class TestModel {
	public static LineSegmentFinderDataSource<TestElement> createDataSource() {
		final List<TestElement> objects = new ArrayList<>();
		addNonPort(objects, null, new Point(100, 100), new Dimension(200, 200));
		addNonPort(objects, null, new Point(200, 350), new Dimension(400, 50));
		final TestElement portParent = addNonPort(objects, null, new Point(500, 100), new Dimension(200, 200));

		// TestObject.createPort(objects.get(1), new Point(500, 100), new Dimension(50, 200),

		// TODO: Reeenable connection points
		addPort(objects, portParent, new Point(500, 130), new Dimension(80, 80),
				// addPort(objects, objects.get(2), new Point(550, 150), new Dimension(50, 50),
				new Point[] { new Point(20, 10), new Point(20, 30), new Point(20, 50) },
				new Point[] { new Point(60, 10), new Point(60, 30), new Point(60, 50) });

		final LineSegmentFinderDataSource<TestElement> testDataSource = new LineSegmentFinderDataSource<TestElement>() {
			@Override
			public List<TestElement> getObjects() {
				return objects;
			}


			@Override
			public TestElement getParent(TestElement e) {
				return e.parent;
			}

			@Override
			public Rectangle getBounds(final TestElement e) {
				return e.bounds;
			}

			@Override
			public boolean isPort(final TestElement e) {
				return e.isPort;
			}
		};

		return testDataSource;
	}

	/**
	 * Represents a box with connection points on left and right.
	 * @param parent must not be a port
	 * @param position
	 * @param size
	 * @return
	 */
	private static TestElement addNonPort(final Collection<TestElement> elements, final TestElement parent,
			final Point position, final Dimension size) {

		final TestElement newObj = new TestElement(parent, position, size, false);
		elements.add(newObj);

		elements.add(new TestElement(newObj, new Point(position.x, position.y + size.height / 2.0)));
		elements.add(
				new TestElement(newObj, new Point(position.x + size.width, position.y + size.height / 2.0)));

		return newObj;
	}

	/**
	 *
	 * @param parent
	 * @param position
	 * @param size
	 * @param exteriorConnectionPoint relative to position
	 * @param interiorConnectionPoint relative to position
	 * @return
	 */
	private static void addPort(final Collection<TestElement> elements, final TestElement parent,
			final Point position, final Dimension size,
			final Point[] exteriorConnectionPointPositions, final Point[] interiorConnectionPointPositions) {
		Objects.requireNonNull(parent, "parent must not be null");

		final TestElement newObj = new TestElement(parent, position, size, true);
		elements.add(newObj);


		// Constrain the segment bounds of the interior and exterior ports so that the segments generated by the graph builder will be horizontal and will
		// only extend outwards in one direction. In a real implementation this would need to consider the side to which the port is docked.
		// final Rectangle nonPortParentBounds = getNonPortBounds(parent, 1);

		for (final Point interiorConnectionPointPosition : interiorConnectionPointPositions) {
			final Rectangle interiorPortSegmentBounds;
//			if (nonPortParentBounds == null) {
//				throw new RuntimeException("Unexpected case");
//			} else {
//				interiorPortSegmentBounds = new Rectangle(
//						new Point(position.x + interiorConnectionPointPosition.x,
//								position.y + interiorConnectionPointPosition.y),
//						new Point(nonPortParentBounds.max.x, position.y + interiorConnectionPointPosition.y));
//			}

			elements.add(new TestElement(newObj, new Point(position.x + interiorConnectionPointPosition.x,
					position.y + interiorConnectionPointPosition.y)));
		}

		// final Rectangle nonPortGrandparentBounds = getNonPortBounds(parent, 2);
		for (final Point exteriorConnectionPointPosition : exteriorConnectionPointPositions) {
//			final Rectangle exteriorPortSegmentBounds;
//			if (nonPortGrandparentBounds == null) {
//				exteriorPortSegmentBounds = new Rectangle(
//						new Point(Double.NEGATIVE_INFINITY, position.y + exteriorConnectionPointPosition.y),
//						new Point(position.x + exteriorConnectionPointPosition.x,
//								position.y + exteriorConnectionPointPosition.y));
//			} else {
//				exteriorPortSegmentBounds = new Rectangle(
//						new Point(nonPortGrandparentBounds.min.x, position.y + exteriorConnectionPointPosition.y),
//						new Point(position.x + exteriorConnectionPointPosition.x,
//								position.y + exteriorConnectionPointPosition.y));
//			}
			elements.add(new TestElement(newObj, new Point(position.x + exteriorConnectionPointPosition.x,
					position.y + exteriorConnectionPointPosition.y)));
		}
	}

	// TODO: Document. Need bounds or position but not both.
	private static class TestElement {
		public final TestElement parent;
		public final Rectangle bounds;
		public final boolean isPort;

		public TestElement(final TestElement parent, final Point position) {
			this.parent = parent;
			this.bounds = new Rectangle(position, position);
			this.isPort = false;
		}

		public TestElement(final TestElement parent, final Point position, final Dimension size, final boolean isPort) {
			this.parent = parent;
			this.bounds = new Rectangle(position, new Point(position.x + size.width, position.y + size.height));
			this.isPort = isPort;
		}
	}
}
